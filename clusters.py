# -*- coding: utf-8 -*-
"""clusters.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15Op4TnfaSuUtWfX7sDipPKmTZrEETK1g
"""

import random
import numpy as np
class SquareGridGraph:
  def __init__(self, rows, cols):
    self.rows = rows
    self.cols = cols
    self.graph = self.create_grid_graph()
    def create_grid_graph(self):
      graph = np.zeros((self.rows * self.cols, self.rows * self.cols),dtype=int)
      for row in range(self.rows):
        for col in range(self.cols):
          node = row * self.cols + col
          #Conectar con los vecinos
          if row > 0:
            neighbor = (row - 1) * self.cols + col # Nodo de arriba
            graph[node][neighbor] = 1
            graph[neighbor][node] = 1
            if row < self.rows - 1:
              neighbor = (row + 1) * self.cols + col # Nodo deabajo
              graph[node][neighbor] = 1
              graph[neighbor][node] = 1
              if col > 0:
                neighbor = row * self.cols + (col - 1) # Nodo de laizquierda
                graph[node][neighbor] = 1
                graph[neighbor][node] = 1
                if col < self.cols - 1:
                  neighbor = row * self.cols + (col + 1) # Nodo de laderecha
                  graph[node][neighbor] = 1
                  graph[neighbor][node] = 1
                  return graph
                  def decimate(self, fraction):
                    if fraction < 0 or fraction > 1:
                      raise ValueError("La fracción de decimación debe estar entre 0 y 1.")
                      total_edges = np.sum(self.graph) // 2 # El factor 2 es para contar las aristas una sola vez
                      edges_to_remove = int(total_edges * fraction)
                      while edges_to_remove > 0:
                        row, col = np.random.randint(0, self.rows),
                        np.random.randint(0, self.cols)
                        node = row * self.cols + col
                        # Buscar una arista válida para eliminar
                        neighbor_indices = np.nonzero(self.graph[node])[0]
                        if len(neighbor_indices) == 0:
                          continue
                          neighbor = np.random.choice(neighbor_indices)
                          self.graph[node][neighbor] = 0
                          self.graph[neighbor][node] = 0
                          edges_to_remove -= 1
                          def __str__(self):
                            return str(self.graph)
                            grid = SquareGridGraph(5, 5)
                            print("Matriz de adyacencia del grafo inicial:")
                            print(grid.graph)
                            fraction_to_remove = 0.25
                            grid.decimate(fraction_to_remove)
                            print(f"Matriz de adyacencia del grafo después de decimar el {fraction_to_remove * 100}% de las aristas:")
                            print(grid.graph)
                            import networkx as nx
                            import matplotlib.pyplot as plt
                            def matriz_a_grafo(matriz):
                              G = nx.Graph()
                              num_nodos = len(matriz)
                              for i in range(num_nodos):
                                for j in range(i, num_nodos):
                                  if matriz[i][j] == 1:
                                    G.add_edge(i, j)
                                    return G
                                    grafo_networkx = matriz_a_grafo(grid.graph)
                                    pos = nx.spring_layout(grafo_networkx)
                                    nx.draw(grafo_networkx, pos, with_labels=True, node_size=100,
                                            node_color='skyblue', font_size=10)
                                    plt.title("Grafo Generado")
                                    plt.show()
                                    import random
                                    import numpy as np
                                    class SquareGridGraph:
                                      def __init__(self, rows, cols):
                                        self.rows = rows
                                        self.cols = cols
                                        self.graph = self.create_grid_graph()
                                        def create_grid_graph(self):
                                          graph = np.zeros((self.rows * self.cols, self.rows * self.cols),dtype=int)
                                          for row in range(self.rows):
                                            for col in range(self.cols):
                                              node = row * self.cols + col
                                              if row > 0:
                                                neighbor = (row - 1) * self.cols + col # Nodo de
                                                arriba
                                                graph[node][neighbor] = 1
                                                graph[neighbor][node] = 1
                                                if row < self.rows - 1:
                                                  neighbor = (row + 1) * self.cols + col # Nodo de
                                                  abajo
                                                  graph[node][neighbor] = 1
                                                  graph[neighbor][node] = 1
                                                  if col > 0:
                                                    neighbor = row * self.cols + (col - 1) # Nodo de la
                                                    izquierda
                                                    graph[node][neighbor] = 1
                                                    graph[neighbor][node] = 1
                                                    if col < self.cols - 1:
                                                      neighbor = row * self.cols + (col + 1) # Nodo de la
                                                      derecha
                                                      graph[node][neighbor] = 1
                                                      graph[neighbor][node] = 1
                                                      return graph
                                                      def decimate(self, fraction):
                                                        if fraction < 0 or fraction > 1:
                                                          raise ValueError("La fracción de decimación debe estar entre0 y 1.")
                                                          total_edges = np.sum(self.graph) // 2
                                                          edges_to_remove = int(total_edges * fraction)
                                                          while edges_to_remove > 0:
                                                            row, col = np.random.randint(0, self.rows),
                                                            np.random.randint(0, self.cols)
                                                            node = row * self.cols + col
                                                            neighbor_indices = np.nonzero(self.graph[node])[0]
                                                            if len(neighbor_indices) == 0:
                                                              continue
                                                              neighbor = np.random.choice(neighbor_indices)
                                                              self.graph[node][neighbor] = 0
                                                              self.graph[neighbor][node] = 0
                                                              edges_to_remove -= 1
                                                              def find_cluster(self, start_node):
                                                                visited = set()
                                                                cluster = set()
                                                                def dfs(node):
                                                                  visited.add(node)
                                                                  cluster.add(node)
                                                                  neighbors = np.nonzero(self.graph[node])[0]
                                                                  for neighbor in neighbors:
                                                                    if neighbor not in visited:
                                                                      dfs(neighbor)
                                                                      if start_node in self.graph:
                                                                        dfs(start_node)
                                                                        return cluster
                                                                        def __str__(self):
                                                                          return str(self.graph)
                                                                          grid = SquareGridGraph(5, 5)
                                                                          fraction_to_remove = 0.25
                                                                          grid.decimate(fraction_to_remove)
                                                                          # Supongamos que queremos encontrar el cluster del punto (0, 0)
                                                                          start_node = 0
                                                                          cluster = grid.find_cluster(start_node)
                                                                          print(f"Cluster de nodos conectados al punto ({start_node // grid.cols},{start_node % grid.cols}):")
                                                                          print(cluster)
                                                                          import networkx as nx
                                                                          import matplotlib.pyplot as plt
                                                                          import numpy as np
                                                                          # Función para calcular los tamaños de los clusters
                                                                          def get_cluster_sizes(graph):
                                                                            clusters = list(nx.strongly_connected_components(graph))
                                                                            cluster_sizes = [len(cluster) for cluster in clusters]
                                                                            return cluster_sizes
                                                                            # Parámetros
                                                                            grid_size = 4 # Tamaño de la cuadrícula
                                                                            num_samples = 100 # Número de muestras para cada fracción de decimación
                                                                            fractions_to_remove = [0.1, 0.2, 0.3, 0.4, 0.5] # Fracciones de decimación a considerar
                                                                            # Almacenar tamaños de cluster para cada fracción de decimación
                                                                            cluster_sizes_data = {}
                                                                            # Realizar múltiples muestras para cada fracción de decimación
                                                                            for fraction_to_remove in fractions_to_remove:
                                                                              cluster_sizes_data[fraction_to_remove] = []
                                                                              for _ in range(num_samples):
                                                                                # Crear una cuadrícula
                                                                                grid = SquareGridGraph(grid_size, grid_size)
                                                                                # Aplicar la decimación
                                                                                grid.decimate(fraction_to_remove)
                                                                                # Calcular los tamaños de los clusters
                                                                                cluster_sizes = get_cluster_sizes(nx.DiGraph(grid.graph))
                                                                                cluster_sizes_data[fraction_to_remove].extend(cluster_sizes)
                                                                                # Graficar histogramas
                                                                                plt.figure(figsize=(10, 6))
                                                                                for fraction_to_remove in fractions_to_remove:
                                                                                  plt.hist(
                                                                                      cluster_sizes_data[fraction_to_remove],
                                                                                      bins=range(1, max(cluster_sizes_data[fraction_to_remove]) + 2),
                                                                                      alpha=0.6,
                                                                                      label=f'Decimación {fraction_to_remove * 100}%')
                                                                                  plt.xlabel('Tamaño de Cluster')
                                                                                  plt.ylabel('Frecuencia')
                                                                                  plt.title('Distribución de Tamaños de Cluster para Varias Fracciones de Decimación')
                                                                                  plt.legend()
                                                                                  plt.grid(True)
                                                                                  plt.show()
                                                                                  import networkx as nx
                                                                                  import matplotlib.pyplot as plt
                                                                                  import numpy as np
                                                                                  # Función para calcular los tamaños de los clusters
                                                                                  def get_cluster_sizes(graph):
                                                                                    clusters = list(nx.strongly_connected_components(graph))
                                                                                    cluster_sizes = [len(cluster) for cluster in clusters]
                                                                                    return cluster_sizes# Parámetros
                                                                                    grid_size = 4 # Tamaño de la cuadrícula
                                                                                    num_samples = 100 # Número de muestras para cada fracción de decimación
                                                                                    fractions_to_remove = np.linspace(0, 1, num=11) # Fracciones de decimación de 0 a 1 en 0.1 incrementos
                                                                                    # Almacenar estadísticas
                                                                                    avg_cluster_sizes = []
                                                                                    std_deviations = []
                                                                                    avg_largest_cluster_sizes = []
                                                                                    # Realizar múltiples muestras para cada fracción de decimación
                                                                                    for fraction_to_remove in fractions_to_remove:
                                                                                      cluster_sizes_data = []
                                                                                      for _ in range(num_samples):
                                                                                        # Crear una cuadrícula
                                                                                        grid = SquareGridGraph(grid_size, grid_size)
                                                                                        # Aplicar la decimación
                                                                                        grid.decimate(fraction_to_remove)
                                                                                        # Calcular los tamaños de los clusters
                                                                                        cluster_sizes = get_cluster_sizes(nx.DiGraph(grid.graph))
                                                                                        cluster_sizes_data.extend(cluster_sizes)
                                                                                        # Calcular estadísticas
                                                                                        avg_cluster_sizes.append(np.mean(cluster_sizes_data))
                                                                                        std_deviations.append(np.std(cluster_sizes_data))
                                                                                        avg_largest_cluster_sizes.append(max(cluster_sizes_data))
                                                                                        # Graficar los resultados
                                                                                        plt.figure(figsize=(12, 6))
                                                                                        plt.subplot(1, 2, 1)
                                                                                        plt.plot(fractions_to_remove, avg_cluster_sizes, marker='o',
                                                                                        label='Tamaño Medio del Cluster')
                                                                                        plt.plot(fractions_to_remove, std_deviations, marker='x',
                                                                                        label='Desviación Estándar')
                                                                                        plt.xlabel('Fracción de Decimación')
                                                                                        plt.ylabel('Tamaño Promedio / Desviación Estándar')
                                                                                        plt.title('Tamaño Medio de los Clusters y Desviación Estándar')
                                                                                        plt.legend()
                                                                                        plt.subplot(1, 2, 2)
                                                                                        plt.plot(fractions_to_remove, avg_largest_cluster_sizes, marker='s',
                                                                                        color='red', label='Tamaño Promedio del Cluster Más Grande')
                                                                                        plt.xlabel('Fracción de Decimación')
                                                                                        plt.ylabel('Tamaño Promedio del Cluster Más Grande')
                                                                                        plt.title('Tamaño Promedio del Cluster Más Grande')
                                                                                        plt.legend()
                                                                                        plt.tight_layout()
                                                                                        plt.show()